(ns defold.script-api-compiler
  (:require [clj-yaml.core :as yaml]
            [clojure.string :as string]))

(defn- split-long-string [s max-len]
  (loop [remaining-s s
         result []]
    (if (<= (count remaining-s) max-len)
      (conj result remaining-s)
      (let [segment (subs remaining-s 0 max-len)
            last-space-idx (.lastIndexOf segment " ")
            split-idx (if (pos? last-space-idx)
                        last-space-idx
                        max-len)]
        (recur (subs remaining-s (inc split-idx))
          (conj result (subs segment 0 split-idx)))))))

(defn- split-lines [text]
  (->> text
    string/split-lines
    (map #(split-long-string % 80))
    flatten))

(defn- compile-comment-description
  ([description] (compile-comment-description description ""))
  ([description prefix]
   (let [lines (split-lines description)]
     (if (= (count lines) 1)
       (println description)
       (do (println (first lines))
           (doseq [line (rest lines)]
             (println (str "---" prefix line))))))))

(defn- compile-param-comment [param]
  (cond
    (= (:type param) "function")
    (do
      (print "---@param"
        (:name param)
        (str "fun("  (string/join ", " (map #(str (:name %) ": " (:type %)) (:parameters param))) ")"))
      (when (:returns param)
        (print ":" (string/join "|" (map :type (:returns param)))))
      (println ""))

    :else
    (do
      (print "---@param" (:name param) (:type param))
      (when (:desc param)
        (print " ")
        (compile-comment-description (:desc param) "    ")))))

(defn- compile-return-comment [return]
  (print "---@return" (:type return))
  (when (:name return)
    (print (str " " (:name return))))
  (when (:desc return)
    (print " ")
    (compile-comment-description (:desc return) "    ")))

(defn- compile-params-list [parameters]
  (string/join ", " (map :name parameters)))

(defn- compile-function [function parent]
  (println "")

  (when (:desc function)
    (doseq [line (split-lines (:desc function))]
      (if (string/starts-with? line "-")
        (println (str "---  " line))
        (println (str "---" line)))))

  (when (:examples function)
    (println "---")
    (println "---    Examples:")
    (println "---")
    (doseq [example (:examples function)]
      (doseq [line (split-lines (:desc example))]
        (println (str "---        " line)))
      (println "---")))

  (doseq [param (:parameters function)]
    (compile-param-comment param))

  (doseq [return (:returns function)]
    (compile-return-comment return))

  (println (str "function " parent "." (:name function) "(" (compile-params-list (:parameters function)) ") end")))

(defn- compile-field [field]
  (print "---@field public" (:name field) (:type field))
  (when (:desc field)
    (print " @")
    (compile-comment-description (:desc field) "    ")))

(defn- is-field? [member]
  (case (:type member)
    "function" false
    "table" false
    true))

(defn- compile-table [table parent]
  (when (:desc table)
    (println (str "---" (:desc table))))

  (when (:type table)
    (println "---@type" (:type table)))

  (println "---@class" (:name table))

  ; parse fields
  (doseq [field (filter is-field? (:members table))]
    (compile-field field))

  (if (nil? parent)
    (println (:name table) "= {}")
    (println (str parent "." (:name table) " = {}")))

  ; parse members
  (doseq [member (:members table)]
    (case (:type member)
      "function" (compile-function member (:name table))
      "table" (compile-table member (:name table))
      nil))

  (when (nil? parent)
    (println "")
    (println "return" (:name table))))

(defn run [script-api-file]
  (when (nil? script-api-file)
    (println "Error: .script_api file was not specified")
    (System/exit 1))

  (let [data       (slurp script-api-file)
        script-api (yaml/parse-string data)]
    (println "-- Generated by atomicptr/defold.nvim")
    (println "")
    (println "---@meta")
    (println "")

    (doseq [module script-api]
      (compile-table module nil))))
